Day5

*event-driven architecture*

Take a Button, for example. A Button is a class â†’ we create its object â†’ it becomes a control on UI. That button has two sides â€” 1ï¸âƒ£ State â€” like enabled, disabled, text, color 2ï¸âƒ£ Events â€” like click, doubleClick, focus, blur

So when you click the button, what happens? Some event is triggered, and then some other part of the system listens and reacts.

Thatâ€™s event-driven architecture.

/*


export class CounterComponent {

    //data member

    @Input() count:number=0;
    @Output() update=new EventEmitter();

   //Event handlers, Event listeners, Callback functions

   //Event handlers
    increment(){ 
      this.count++;
      this.update.emit({count:this.count});
    }
    decrement(){
      this.count--;
      this.update.emit({count:this.count});
    }
}


*/


@Output() countChanged = new EventEmitter<number>();

What is this EventEmitter? 
Itâ€™s imported from '@angular/core'. So yes â€” itâ€™s a class. A special Angular-provided class that helps us define custom events.


this.countChanged.emit(this.counter);

thatâ€™s your trigger point. This is where your component says,
â€œHey, something changed here â€” whoeverâ€™s listening, please react!â€


Mentor (asking students): Now tell me â€” If one component emits an event, whoâ€™s going to handle it?

Exactly â€” another component! Maybe the parent component thatâ€™s listening for it.

*So this is the key idea: ğŸ“¤ One component emits an event ğŸ“¥ Another component listens and reacts*
-----------------------------------------------------------------------

Mentor (pauses, then softly adds): And before I wrap up, one small thing, a best practice. When you name your custom event, donâ€™t start with â€œonâ€ â€” like onChange or onClick.

Thatâ€™s the handlerâ€™s name, not the eventâ€™s name.

The event name should be a verb, describing what happened.

So instead of:

@Output() onCountChange = new EventEmitter<number>();
Prefer:

@Output() countChanged = new EventEmitter<number>();
Sounds cleaner, more semantic, and matches Angular conventions.

------------------------------------------------------------------


So remember â€” In Angular, every @Output() with EventEmitter is your way of saying:

â€œIâ€™m alive. I respond. I communicate.â€

Thatâ€™s the spirit of event-driven UI â€” from C++ callbacks, to C# delegates, to ASP.NET controls, and now to Angular components.

	
onUpdate(data: any) {
  if (data) {
    this.product.likes = data.count;
  }
}

â€œThis function will be called when the event occurs.â€

here our onUpdate() acts as a callback for the event emitted by CounterComponent.
----------------------------------------------------------------

export class ProductDetailsComponent implements OnInit {
  ngOnInit(): void {
    // initialization logic here
  }
}

 OnInit? This is not an event, but it behaves like one. Itâ€™s an interface â€” given by Angular to hook into a component lifecycle event.

When you implement OnInit, Angular expects you to override the method ngOnInit(). And that method runs automatically when the component gets initialized.

ğŸ“¦ Component Lifecycle Hook = Interface + Auto Triggered Method

Example: OnInit â†’ ngOnInit() OnDestroy â†’ ngOnDestroy()



So if tomorrow you want to fetch data from a REST API before your component appears, where will you write that logic? Exactly â€” inside ngOnInit().


----------------------------------------------------------------------

So, today weâ€™ve seen that:

Javaâ€™s ActionListener = Angularâ€™s EventEmitter + @Output + Callback
Javaâ€™s Interface method = Angularâ€™s Lifecycle Interface (OnInit)
And the best part â€” TypeScript lets us blend object-oriented structure with event-driven design.
So, your ProductComponent now behaves like a small intelligent UI object â€” it knows how to emit events, listen to changes, and initialize itself gracefully.

Thatâ€™s the essence of modern UI architecture.

---------------------------------------------------------
Letâ€™s imagine this: Youâ€™re building a product dashboard. On that dashboard, you have two components â€”

1ï¸âƒ£ CounterComponent â†’ where user clicks on â€œLikeâ€ button. 2ï¸âƒ£ ProductComponent â†’ which shows how many likes that product has received.

Now, both are Angular components. Both are objects. And like any good object in OOP, they have state and behavior.

But hereâ€™s the problem â€” when you click the â€œLikeâ€ button inside the CounterComponent, how does ProductComponent know that something has changed?

They are not directly connected like two functions calling each other. They are connected through Angularâ€™s event system.

In the old days, when we wrote C++, we used callback functions for this. In C#, we used delegates and events. In ASP.NET WebForms, we used things like OnClick, OnSelectedIndexChanged.

And when we came into the modern Angular world, we were introduced to this magical class called EventEmitter.

@Output() countChanged = new EventEmitter<number>();

Itâ€™s like raising your hand in a classroom. The @Output decorator marks your hand as visible to others. And the EventEmitter actually sends the message.

-------------------------------------------------

Youâ€™ve got your property binding:
[ count ]="product.likes"
Youâ€™ve got your event binding for the update event:
(update)="onUpdate($event)"

----------------------------

Here, your custom event is called update â€” simple, meaningful, and intuitive. And notice how youâ€™re binding it to a listener function:

(update)="$event"

That $event â€” this little dollar sign â€” is super important.

Whatever object your component emits â€” whether itâ€™s a number, a string, or a JSON object â€” $event carries it to your handler function.

In TypeScript/Angular, you write:
this.update.emit({ count: this.product.likes });

and in the parent HTML:
(update)="onUpdate($event)"


Now, look at the input property:

@Input() product: Product;

Because data flows from parent to child using property binding.

Imagine you want to display a list of products:

The parent component has an array of products.
Each child component â€” ProductDetailsComponent â€” receives a single product via @Input().
This way, each child component is isolated, manages its own state, and still reacts to updates.
This is component-based architecture in Angular â€” itâ€™s like a mini OOP system inside the UI.

--------------------------------------------------------------


So when you see multiple products on the screen, each ProductDetailsComponent is an object in this component tree.

Each object has state (product.likes, product.title, product.imageUrl)
Each object has events (update)
Angularâ€™s Ivy engine efficiently updates only the affected nodes in the DOM â€” not the entire page!
So, what weâ€™ve achieved here is a data-first approach:

1ï¸âƒ£ Define your entities first â€” like Product. 2ï¸âƒ£ Pass these entities to components via @Input(). 3ï¸âƒ£ Emit events to communicate changes back to the parent. 4ï¸âƒ£ Let the Angular engine (Ivy) take care of rendering efficiently.

This is how enterprise-level Angular applications work.