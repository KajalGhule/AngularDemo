Angular NotesWhy Node.js for Angular?Because JavaScript was originally designed to run only in browsers. Node.js lets JavaScript run on the server side too â€” outside the browser.Ravi Tambade (10:54) Excellent! So Node.js is a server-side runtime for JavaScript â€” like how .NET runs C# or Java runs in JVM.Runtime Environments & EJS(embedded JavaScript or Express JavaScript)Â Every technology stack needs a runtime. If you build in Java â†’ you need JVM. If you build in .NET â†’ you need CLR. If you build with Node â†’ you have the Node runtime.In the Node runtime, we use a framework called Express, and within Express, we can use a view engine like EJS. It allows us to mix HTML + JavaScript together â€” but this JavaScript runs on the server side, not the browser.So you might have files like:login.ejsregister.ejsdashboard.ejsAll rendered by the server.Thatâ€™s server-side rendering with EJS â€” similar to how JSP or Razor works.the runtime is that execution environment where your code lives and runs.And now you can understand why we need Node.js even when building Angular apps â€” because the Angular CLI and compiler themselves run in that runtime.---05-11-2025 2:40---Concept				|		Description---Runtime				|	The execution environment that runs your code (Node.js, JVM, CLR, Python VM).---Server-Side View Technologies	|	JSP, PHP, ASP, Razor, EJS â€” HTML + logic executed on server.---Client-Side View Technologies	|	Angular, React, Vue â€” UI rendered in browser.---SPA vs MPA			|	SPA â†’ single page with dynamic views; MPA â†’ multiple HTML pages.---Servers				|	Programs running in background (Tomcat, Express, IIS).---Linux / Windows Server		|	Hosts the runtime and manages hardware + network resources.---All these â€” Kestrel, Tomcat, Express, NGINX, Apache â€” are examples of web servers, and theyâ€™re responsible for hosting your web applications.If youâ€™re building with Java â†’ you might deploy on Tomcat.If youâ€™re on .NET â†’ you get Kestrel (or earlier IIS).If itâ€™s Node.js â†’ you use the built-in HTTP server or Express.And beyond your web server, you may also have a database:MySQLMS SQL ServerPostgreSQLOracle---Every browser â€” Chrome, Edge, Firefox, Safari â€” is like a small runtime environment too. It can send requests, receive responses, and render what you see on the screen.Each browser has:A JavaScript Engine (e.g. V8, SpiderMonkey, Chakra)An HTML Rendering Engine (e.g. Blink, WebKit)---3:17Â If the browser already has a JavaScript engine, why do we need Node.js?Node.js does not run inside the browser. It runs on the developer machine or server â€” it gives developers a runtime to build, test, and bundle their front-end code.So when weâ€™re building Angular apps, Node helps:Compile TypeScript â†’ JavaScriptServe the app locally (ng serve)Bundle & deploy (ng build)Node.js is your developer runtime, not the runtime of the final web app.âœ… Source Code â€” written in Java, C#, or TypeScript âœ… SDK (Software Development Kit) â€” includes compilers, libraries, and tools âœ… IDE â€” where we write, debug, and run code (like VS Code, IntelliJ, or Visual Studio) âœ… Server â€” to test or host our applications (Kestrel, Tomcat, Express)Shekhar Kumar (43:00) So, we need an IDE to write code and a server to run and test it.Ravi Tambade (43:10) Exactly! Developers need both â€” an environment to code and an environment to run.---Concept				DescriptionKestrel			Built-in web server in .NET Core â€” replaces IIS for local hosting.Runtime			Platform layer that executes code (JVM, CLR, Node.js, Python).Browser Engines		HTML Renderer + JavaScript Engine work together to display web apps.DOM Tree		Memory representation of the HTML document structure.V8 Engine		Chromeâ€™s JavaScript engine â€” the brain of modern browsers.Node.js			JavaScript runtime for developers â€” used for building and serving SPAs.SDK			Toolkit with compilers, libraries, and tools needed to develop software.---3:38â€œTo build Angular applications, we need a similar SDK. And that SDK is called Angular CLI.â€npm install -g @angular/cli  --> creates your entire Angular development environmentThink of Angular CLI as your personal assistant. It helps you create, build, test, and serve your Angular applications with just a few commands.---06-11-2025 1:13Two-way data binding in AngularJSTwo-way data binding in AngularJS (version 1.x) means that the data in the UI (View) and the JavaScript model (Scope/Controller) are automatically synchronized.If the user changes data in the UI â†’ the model updates.If the model changes â†’ the UI updates automatically.So both stay in sync without writing extra code.---React also introduced:Components â†’ Reusable, modular building blocksProps & State â†’ Data flow in one direction (unidirectional)JSX â†’ Writing HTML inside JavaScript (a new concept then!)---4:12Â Angular CLI gives you an entire toolbox of commands:---Command	    |		Purpose---ng new	    |	Create a new Angular project---ng serve    |	Run the project in development mode---ng build    |	Compile the project for production---ng test	    |	Run the unit tests------When you create a project using Angular CLI, it doesnâ€™t just build code â€” it also prepares you for testing.Inside your project, youâ€™ll find two built-in testing tools:ğŸ§  Jasmine â€“ the test engine (like JUnit for Java or NUnit for .NET)âš¡ Karma â€“ the test runner that actually executes your tests in a browser environmentSo when you run:ng test---Letâ€™s visualize the Angular Development Environment we just built:â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚              Hardware                  â”‚â”‚   (Laptop / Desktop Machine)           â”‚â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤â”‚           Operating System             â”‚â”‚     Windows / Linux / Mac OS           â”‚â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤â”‚              Node.js                   â”‚â”‚  + npm (Package Manager)               â”‚â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤â”‚            Angular CLI                 â”‚â”‚  (ng new, ng serve, ng build, ng test) â”‚â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤â”‚        Angular Project (SRC)           â”‚â”‚   TypeScript + HTML + CSS + Tests      â”‚â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜---A compiler takes your source code and converts it into executable code â€” like .exe for Windows or .dll for .NET. A transpiler, on the other hand, converts code from one language into another language â€” not directly into an executable.In Angular, we write our code in TypeScript (.ts files). But browsers donâ€™t understand TypeScript â€” they only understand JavaScript.So, Angular uses the TypeScript Compiler (TSC) as a transpiler:TypeScript (.ts) â†’ TSC â†’ JavaScript (.js)---***Building the ProjectIn the terminal, type:ng buildWatch what happens:Angular CLI searches your .ts files.TSC transpiles TypeScript into JavaScript.The CLI bundles all the JavaScript files and minifies them.After a few seconds, youâ€™ll see files like:main.jsruntime.jspolyfills.jsstyles.cssThese are your compiled, optimized Angular application files â€” ready to be deployed.Think of it like this:Java developers compile .java â†’ .class â†’ .jar.NET developers compile .cs â†’ .dll â†’ .exeAngular developers transpile .ts â†’ .js â†’ deployable app---Why do we even need this http://localhost:4200 thing?You type http://localhost:4200 in your browser.The browser sends an HTTP request to the server.The Angular Development Server running on port 4200 receives the request.It serves the compiled, bundled JavaScript, CSS, and HTML back to the browser.The browser loads the files, the JavaScript engine runs your code, and the HTML is rendered beautifully.---Step 3: Library vs FrameworkNow, letâ€™s pause for a key concept. Angular isnâ€™t just a library like jQuery.Library: Just a set of reusable functions. Example: jQuery. You call a function when you need it.Framework: Provides architecture, best practices, modular approach, folder structure, and design patterns. Example: Angular, ASP.NET MVC, Spring Boot.---Understanding package.json & Angular ModulesOpen package.json. This is not TypeScript or source code, itâ€™s a JSON configuration file that contains:Dependencies (Angular core, forms, router, RxJS, etc.)Scripts (commands to build, test, and serve)Notice something important â€” these dependencies arenâ€™t just random libraries. They are Angular Modules, not plain functions.Java developers call them packages.NET developers call them assembliesAngular calls them modulesModules give you:Reusable, self-contained logicWell-defined folder structureIntegration with the Angular framework---07-11-2025Angular Components, Templates, and Data BindingEach component in Angular has **three important parts**:1. **Template (HTML)** â€“ This defines the **look and feel** of the component. In our project, thatâ€™s `app.component.html`.2. **Style (CSS)** â€“ Every component can have its **own style sheet**, which is `app.component.css`. You can customize the visual appearance here.3. **Logic (TypeScript)** â€“ The actual behavior of the component is defined in `app.component.ts`.So, every component in Angular has a **separation of concerns**:* **HTML:** What the user sees* **CSS:** How it looks* **TS:** How it behaves### ğŸ§© Step 1: Decorators and MetadataNotice the `@Component` decorator?* In **Java**, we call this an **annotation**.* In **C#**, itâ€™s called an **attribute**.* In **TypeScript/Angular**, itâ€™s called a **decorator**.Decorators provide **metadata** that tells Angular how to handle this class at **runtime**.---### ğŸ— Step 2: The Component ClassInside `app.component.ts`, we have a class called `AppComponent`.```tsexport class AppComponent {&nbsp;   title = "Nihilent";&nbsp;   product = { &nbsp;       title: "Gerbera", &nbsp;       description: "Wedding Flower", &nbsp;       price: 15 &nbsp;   };}```* This class holds the **data** and **logic** of the component.* The **HTML template** only presents this data.* The **CSS** only styles it.This is a classic **Separation of Concerns (SOC)**.---### ğŸ”„ Step 3: Data Binding in ActionLetâ€™s see how to **show this data dynamically** in `app.component.html`.```html<div>&nbsp;   <h3>{{ title }}</h3>&nbsp;   <p>{{ product.description }}</p>&nbsp;   <p>Price: {{ product.price }}</p></div>```* The `{{ }}` syntax is called **interpolation**.* It binds the **data from the TypeScript class** to the **HTML template**.* This makes your UI **dynamic**, not static.---This is the **power of Angular components**:* **TS class** â†’ holds data and logic* **HTML template** â†’ presents the data* **CSS** â†’ styles the component* **Decorator** â†’ metadata for Angular runtime---### ğŸ“  *Angular â€“ Pipes, Modules, and Dynamic UI*Angular gives us a **clean, structured way to bind data and transform it**, all on the **client side**.### ğŸ§© Step 1: Using a PipeLetâ€™s say we have a product object in `app.component.ts`:```tsexport class AppComponent {&nbsp;   product = { title: "Wedding Flower", price: 15 };}```Now, in `app.component.html`, I want to show the price as **Indian Rupees**.I go to the HTML template and write:```html<p>Price: {{ product.price | currency:'INR' }}</p>```* The `| currency` part is called a **pipe**.* Pipes let you **transform data** before it appears in the UI.* `'INR'` specifies the currency format.This is a **classic Angular scenario** â€” pipes, directives, and modules are part of Angular **packages**, not automatically available everywhere.To fix it:1. Go to `app.module.ts`.2. Import the **CommonModule**:```tsimport { CommonModule, CurrencyPipe } from '@angular/common';```3. Add `CommonModule` to the `imports` array of your module:```ts@NgModule({&nbsp; declarations: \[AppComponent],&nbsp; imports: \[BrowserModule, CommonModule],&nbsp; bootstrap: \[AppComponent]})export class AppModule {}```* Now the `currency` pipe is **registered and ready**.* Refresh your browser â€” voila! The price now shows as **â‚¹15.00**.---### ğŸ§© Step 3: What We Just Learned1. **Angular uses decorators and metadata** (`@Component`) â€” no jQuery, no manual DOM manipulation.2. **TypeScript class** holds your data (`product`, `title`).3. **HTML template** binds data dynamically using **interpolation** (`{{ }}`).4. **Pipes** transform your data (`| currency`).5. **Modules** manage dependencies â€” if you miss importing `CommonModule`, your pipe wonâ€™t work.---### ğŸ§© Step 4: Component Selector DiscussionAlso, a quick tip on **component selectors**:* In `app.component.ts`, you see `selector: 'app-root'`.* This is the HTML tag that represents this component.* You can rename it, e.g., `selector: 'tfl-root'`, but then you must update it in `index.html`.* The convention is **kebab-case** (`product-list`, `login-component`), but Angular will work even if you skip the hyphen.---So today weâ€™ve learned:âœ… Angular is **component-based** â€” HTML, CSS, and TS separated.âœ… **Data binding** and **interpolation** connect the class with the template.âœ… **Pipes** like `currency` transform data dynamically.âœ… **Modules** like `CommonModule` must be imported to enable certain Angular features.âœ… **Selectors** define how your component is referenced in HTML.Angular is **a new way of learning frontend development** â€” no messy DOM manipulation, no server-side hacks, just structured, maintainable, dynamic UI development.---1. The **TypeScript compiler** sees the `import` at the top and resolves it during **compile time**.2. The **Angular engine (view engine)** looks for the pipe when the app runs in the browser.So we are telling **TypeScript** and **Angular engine** separately about the pipe.---**Step 3: Why Two Imports?**One student, Shekhar, asked a great question:> â€œIf we already imported `CommonModule` at the top, why do we also have to declare it in the module imports?â€**Ravi:**Ah, excellent question! There are **two responsibilities** here:1. **Top-level import** â†’ TypeScript compiler needs it to resolve syntax. Without it, youâ€™ll get **compile-time errors**.2. **Module-level import** â†’ Angular engine (the runtime view engine) needs it to locate the pipe **during rendering** in the browser.Think of it like: **compile-time knows the words, runtime knows the meaning**. Both are necessary.---**Step 4: Understanding Decorators and Structure*** Every component has a **decorator** like `@Component`.* Inside it:Â  * `selector` â†’ HTML tag for this componentÂ  * `templateUrl` â†’ path to HTML fileÂ  * `styleUrls` â†’ path to CSS fileThese are **not optional** â€” Angular uses this metadata to **link your class with UI**.Angular is a **paradigm shift**. We are not just writing JavaScript anymore â€” itâ€™s **structured, component-based, module-driven frontend architecture**.